package main

import (
	"flag"
	"fmt"
	"net"
	//"io"
//	"io/ioutil"
//	"net/http"
	"os"
)

var (
	proxyaddress string
//	port    int
)

const (
    MSI_HOST = "169.254.169.254"
    MSI_PORT = "80"
    PROTOCOL_TYPE = "tcp"
)

func init() {
	fmt.Println("init() called")
	flag.StringVar(&proxyaddress, "proxyaddress", "", "the target (<host>:<port>)")
//	flag.IntVar(&port, "port", 80, "the target port number")
	fmt.Println("proxyaddress is " + proxyaddress)
}



func check(err error) {
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
}

// Handles incoming requests.

func handleRequest(conn net.Conn) {

	// connect to the proxy container
	// How to get environment variable ?

	// check to see what's recevied from the client container
	// Make a buffer to hold incoming data.
	buf := make([]byte, 1024)
	// Read the incoming connection into the buffer.
	bytecout, err := conn.Read(buf)
	if err != nil {
		fmt.Println("Error reading:", err.Error())
	}
	fmt.Printf("bytecout = %d\n", bytecout)
	fmt.Printf("buf =  \n" + string(buf[:]))

        // 1. convert buf into a new request
        // 2. update the header (add the remote address, value pair)

	//httpRequest, err: = ReadRequest(b *bufio.Reader) (*Request, error)

	// send the request to the proxy container

        // get the result back

	// write the response back to the client container
	// Send a response back to person contacting us.

	conn.Write([]byte("Message received."))
	// Close the connection when you're done with it.
	  conn.Close()


/*
	fmt.Printf("Attemping to connect to " + proxyaddress)
	targetConn, err := net.Dial("tcp", proxyaddress)
	if err != nil {
		fmt.Println("could not connect to target", err)
	}
	defer targetConn.Close()

	fmt.Printf("connection to server %v established!\n", targetConn.RemoteAddr())

	go func() { io.Copy(targetConn, conn) }()
	go func() { io.Copy(conn, targetConn) }()
*/
/*
	fmt.Println("Forwarding MSI request to proxy container")
	fmt.Println("Requesting MSI metadata from "+ proxyaddress)
	resp, err := http.Get("https://" + proxyaddress)
	body, err := ioutil.ReadAll(resp.Body)
	fmt.Println("err: " + err.Error())

	check(err)
	check(err)

	fmt.Println("returned MSI data: " + string(body[:]))
	fmt.Println(len(body))
*/
}	


func main() {

	fmt.Println("Hello world!")
	flag.Parse()

	fmt.Println("Listen for incoming connections..")

    	// Listen for incoming connections.

    	// l is type TCPListener

    	l, err := net.Listen(PROTOCOL_TYPE, MSI_HOST+":"+MSI_PORT)
    	if err != nil {
        	fmt.Println("Error listening:", err.Error())
        	os.Exit(1)
    	}
    	// Close the listener when the application closes.
    	defer l.Close()

    	fmt.Println("Listening on " + MSI_HOST + ":" + MSI_PORT)
    	for {
        	// Listen for an incoming connection.
        	conn, err := l.Accept()
        	if err != nil {
            	fmt.Println("Error accepting: ", err.Error())
            	os.Exit(1)
        }
	// print out local and remote address
        // LocalAddr returns the local network address.
	fmt.Println("Local address:" + conn.LocalAddr().String())

        // RemoteAddr returns the remote network address.
	fmt.Println("Remote address:" + conn.RemoteAddr().String())

        // Handle connections in a new goroutine.
        go handleRequest(conn)
    }
    fmt.Println("Done")
}



/*
func handleRequest(conn net.Conn) {
	
	  // Make a buffer to hold incoming data.
	  buf := make([]byte, 1024)
	  // Read the incoming connection into the buffer.
	  _, err := conn.Read(buf)
	  if err != nil {
		fmt.Println("Error reading:", err.Error())
	  }
	  // Send a response back to person contacting us.
	  conn.Write([]byte("Message received."))
	  // Close the connection when you're done with it.
	  conn.Close()
	}

*/

/*
func main() {
	fmt.Println("hello world")
	resp, err := http.Get("https://google.com")
	check(err)
	body, err := ioutil.ReadAll(resp.Body)
	check(err)
	fmt.Println(len(body))
}*/